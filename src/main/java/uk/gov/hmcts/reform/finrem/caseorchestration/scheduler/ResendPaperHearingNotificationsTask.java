package uk.gov.hmcts.reform.finrem.caseorchestration.scheduler;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;
import uk.gov.hmcts.reform.ccd.client.model.CaseDetails;
import uk.gov.hmcts.reform.finrem.caseorchestration.helper.managehearings.HearingCorrespondenceHelper;
import uk.gov.hmcts.reform.finrem.caseorchestration.mapper.FinremCaseDetailsMapper;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.CaseDocument;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.CaseType;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.DocumentCollectionItem;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.FinremCaseData;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.FinremCaseDetails;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.managehearings.PartyOnCaseCollectionItem;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.managehearings.hearings.Hearing;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.managehearings.hearings.HearingLike;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.managehearings.hearings.ManageHearingsCollectionItem;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.managehearings.hearings.VacateOrAdjournedHearing;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.managehearings.hearings.VacatedOrAdjournedHearingsCollectionItem;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.wrapper.ManageHearingsWrapper;
import uk.gov.hmcts.reform.finrem.caseorchestration.notifications.notifiers.NotificationParty;
import uk.gov.hmcts.reform.finrem.caseorchestration.notifications.notifiers.SendCorrespondenceEvent;
import uk.gov.hmcts.reform.finrem.caseorchestration.service.CcdService;
import uk.gov.hmcts.reform.finrem.caseorchestration.service.NotificationService;
import uk.gov.hmcts.reform.finrem.caseorchestration.service.SystemUserService;
import uk.gov.hmcts.reform.finrem.caseorchestration.utils.csv.CaseReferenceCsvLoader;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import static uk.gov.hmcts.reform.finrem.caseorchestration.notifications.notifiers.NotificationParty.getNotificationPartyFromRole;

/**
 * Scheduled task to resend hearing bundle paper correspondence generated by hearing Addition or Vacation.
 * Documents are sent to the applicant / respondent / interveners if they are LiPs.
 * Case references are read from an encrypted file. The file has a header row, and each case reference is on a new line.
 * To enable the task to execute set environment variables:
 * <ul>
 *     <li>CRON_RESEND_PAPER_HEARING_NOTIFICATIONS_ENABLED=true</li>
 *     <li>TASK_NAME=ResendPaperHearingNotificationsTask</li>
 *     <li>CRON_RESEND_PAPER_HEARING_NOTIFICATIONS_CASE_TYPE_ID=Case type for cases in the file</li>
 *     <li>CRON_RESEND_PAPER_HEARING_NOTIFICATIONS_FILENAME=The encrypted case references filename</li>
 *     <li>CRON_CSV_FILE_DECRYPT_KEY=Key to decrypted case references file</li>
 * </ul>
 */
@Component
@Slf4j
public class ResendPaperHearingNotificationsTask extends EncryptedCsvFileProcessingTask {
    private static final String TASK_NAME = "ResendPaperHearingNotificationsTask";
    private static final String SUMMARY = "DFR-4546 - Resend Hearing Notifications for Paper Cases";

    @Value("${cron.resendPaperHearingNotifications.enabled:false}")
    private boolean taskEnabled;
    @Value("${cron.resendPaperHearingNotifications.caseTypeId:FinancialRemedyContested}")
    private String caseTypeId;
    @Value("${cron.resendPaperHearingNotifications.caseListFileName:resendPaperHearingNotifications-encrypted.csv}")
    private String csvFile;

    // Service manual hearing notification up until 23rd Feb 2026
    private final LocalDate serviceManualHearingNoticeCutOff = LocalDate.of(2026, 2, 22);
    private final LocalDate serviceManualVacatedNoticeCutOff = LocalDate.of(2026, 2, 19);

    private final NotificationService notificationService;
    private final ApplicationEventPublisher applicationEventPublisher;
    private final HearingCorrespondenceHelper hearingCorrespondenceHelper;

    public ResendPaperHearingNotificationsTask(CaseReferenceCsvLoader csvLoader, CcdService ccdService,
                                               SystemUserService systemUserService,
                                               FinremCaseDetailsMapper finremCaseDetailsMapper,
                                               NotificationService notificationService,
                                               ApplicationEventPublisher applicationEventPublisher,
                                               HearingCorrespondenceHelper hearingCorrespondenceHelper) {
        super(csvLoader, ccdService, systemUserService, finremCaseDetailsMapper);
        this.notificationService = notificationService;
        this.applicationEventPublisher = applicationEventPublisher;
        this.hearingCorrespondenceHelper = hearingCorrespondenceHelper;
    }

    @Override
    protected boolean isUpdatedRequired(CaseDetails caseDetails) {
        FinremCaseDetails finremCaseDetails = finremCaseDetailsMapper.mapToFinremCaseDetails(caseDetails);
        ManageHearingsWrapper hearingsWrapper = finremCaseDetails.getData().getManageHearingsWrapper();

        List<Hearing> hearings = hearingsWrapper.getHearings().stream()
            .map(ManageHearingsCollectionItem::getValue)
            .filter(value -> value.getHearingDate().isAfter(serviceManualHearingNoticeCutOff))
            .toList();

        List<VacateOrAdjournedHearing> vacatedHearings = hearingsWrapper.getVacatedOrAdjournedHearings().stream()
            .map(VacatedOrAdjournedHearingsCollectionItem::getValue)
            .filter(value -> value.getHearingDate().isAfter(serviceManualVacatedNoticeCutOff))
            .toList();

        // Sanity check case has hearings past from the 3-week manual service notice period
        if (!hearings.isEmpty() || !vacatedHearings.isEmpty()) {
            log.warn("Case ID: {} does not have hearings or vacated hearings within the cut off to post", finremCaseDetails.getId());
            return false;
        }

        return isApplicantPostalRequired(finremCaseDetails)
            || isRespondentPostalRequired(finremCaseDetails)
            || isIntervenerOnePostalRequired(finremCaseDetails)
            || isIntervenerTwoPostalRequired(finremCaseDetails)
            || isIntervenerThreePostalRequired(finremCaseDetails)
            || isIntervenerFourPostalRequired(finremCaseDetails);
    }

    @Override
    protected void executeTask(FinremCaseDetails finremCaseDetails) {
        FinremCaseData caseData = finremCaseDetails.getData();

        String systemUserToken = getSystemUserToken();

        List<ManageHearingsCollectionItem> hearings = caseData.getManageHearingsWrapper().getHearings().stream()
            .filter(hearingItem -> hearingItem.getValue().getHearingDate().isAfter(serviceManualHearingNoticeCutOff))
            .toList();

        List<VacatedOrAdjournedHearingsCollectionItem> vacatedHearings = caseData.getManageHearingsWrapper().getVacatedOrAdjournedHearings().stream()
            .filter(hearingItem -> hearingItem.getValue().getHearingDate().isAfter(serviceManualVacatedNoticeCutOff))
            .toList();

        log.info(getActionLog(finremCaseDetails));

        hearings.forEach(hearing -> processHearingPaperNotification(finremCaseDetails, hearing, systemUserToken));
        vacatedHearings.forEach(vacatedHearing -> processVacatedHearingPaperNotification(finremCaseDetails, vacatedHearing, systemUserToken));
    }

    @Override
    protected String getCaseListFileName() {
        return csvFile;
    }

    @Override
    protected String getTaskName() {
        return TASK_NAME;
    }

    @Override
    protected boolean isTaskEnabled() {
        return taskEnabled;
    }

    @Override
    protected CaseType getCaseType() {
        return CaseType.forValue(caseTypeId);
    }

    @Override
    protected String getSummary() {
        return SUMMARY;
    }

    @Override
    protected String getDescription(FinremCaseDetails finremCaseDetails) {
        return getActionLog(finremCaseDetails);
    }

    private boolean isApplicantPostalRequired(FinremCaseDetails caseDetails) {
        return !notificationService.isApplicantSolicitorDigitalAndEmailPopulated(caseDetails);
    }

    private boolean isRespondentPostalRequired(FinremCaseDetails caseDetails) {
        return !notificationService.isRespondentSolicitorDigitalAndEmailPopulated(caseDetails);
    }

    private boolean isIntervenerOnePostalRequired(FinremCaseDetails caseDetails) {
        return !notificationService.isIntervenerSolicitorDigitalAndEmailPopulated(caseDetails.getData().getIntervenerOneWrapperIfPopulated(), caseDetails);
    }

    private boolean isIntervenerTwoPostalRequired(FinremCaseDetails caseDetails) {
        return !notificationService.isIntervenerSolicitorDigitalAndEmailPopulated(caseDetails.getData().getIntervenerTwoWrapperIfPopulated(), caseDetails);
    }

    private boolean isIntervenerThreePostalRequired(FinremCaseDetails caseDetails) {
        return !notificationService.isIntervenerSolicitorDigitalAndEmailPopulated(caseDetails.getData().getIntervenerThreeWrapperIfPopulated(), caseDetails);
    }

    private boolean isIntervenerFourPostalRequired(FinremCaseDetails caseDetails) {
        return !notificationService.isIntervenerSolicitorDigitalAndEmailPopulated(caseDetails.getData().getIntervenerFourWrapperIfPopulated(), caseDetails);
    }

    private void processHearingPaperNotification(FinremCaseDetails caseDetails, ManageHearingsCollectionItem hearingItem, String authToken) {

        Hearing hearing = hearingItem.getValue();

        List<NotificationParty> partiesToPost = getPostalParties(hearing, caseDetails);

        List<CaseDocument> hearingDocumentsToPost = new ArrayList<>(caseDetails.getData().getManageHearingsWrapper().getAssociatedHearingDocuments(hearingItem.getId()));
        hearingCorrespondenceHelper.getMiniFormAIfRequired(caseDetails.getData(), hearing)
            .ifPresent(hearingDocumentsToPost::add);
        hearingDocumentsToPost.addAll(hearing.getAdditionalHearingDocs().stream().map(DocumentCollectionItem::getValue).toList());

        log.info("Case ID: {} Sending hearing correspondence for parties: {}", caseDetails.getId(), partiesToPost);

        applicationEventPublisher.publishEvent(SendCorrespondenceEvent.builder()
            .notificationParties(partiesToPost)
            .emailNotificationRequest(null)
            .emailTemplate(null)
            .documentsToPost(hearingDocumentsToPost)
            .caseDetails(caseDetails)
            .authToken(authToken)
            .build());
    }

    private void processVacatedHearingPaperNotification(FinremCaseDetails caseDetails, VacatedOrAdjournedHearingsCollectionItem vacatedHearingItem, String authToken) {
        VacateOrAdjournedHearing vacateHearing = vacatedHearingItem.getValue();

        List<NotificationParty> partiesToPost = getPostalParties(vacateHearing, caseDetails);

        List<CaseDocument> hearingDocumentsToPost = new ArrayList<>(caseDetails.getData().getManageHearingsWrapper().getAssociatedHearingDocuments(vacatedHearingItem.getId()));

        log.info("Case ID: {} Sending vacated hearing correspondence for parties: {}", caseDetails.getId(), partiesToPost);

        applicationEventPublisher.publishEvent(SendCorrespondenceEvent.builder()
            .notificationParties(partiesToPost)
            .emailNotificationRequest(null)
            .emailTemplate(null)
            .documentsToPost(hearingDocumentsToPost)
            .caseDetails(caseDetails)
            .authToken(authToken)
            .build());
    }

    /**
     * Determines if the given party requires postal notification.
     */
    private List<NotificationParty> getPostalParties(HearingLike hearing, FinremCaseDetails caseDetails) {

        List<PartyOnCaseCollectionItem> partiesOnHearing = hearing.getPartiesOnCase();

        return partiesOnHearing.stream()
            .map(partyOnCase -> getNotificationPartyFromRole(partyOnCase.getValue().getRole())).filter(Objects::nonNull)
            .filter(notificationParty -> isPostalRequired(notificationParty, caseDetails))
            .toList();
    }

    private boolean isPostalRequired(NotificationParty party, FinremCaseDetails caseDetails) {
        return switch (party) {
            case APPLICANT -> isApplicantPostalRequired(caseDetails);
            case RESPONDENT -> isRespondentPostalRequired(caseDetails);
            case INTERVENER_ONE -> isIntervenerOnePostalRequired(caseDetails);
            case INTERVENER_TWO -> isIntervenerTwoPostalRequired(caseDetails);
            case INTERVENER_THREE -> isIntervenerThreePostalRequired(caseDetails);
            case INTERVENER_FOUR -> isIntervenerFourPostalRequired(caseDetails);
            default -> false;
        };
    }

    private String getActionLog(FinremCaseDetails finremCaseDetails) {
        return String.format("""
                Case ID %s re-sending hearing correspondence for parties:
                 applicant: %s,
                 respondent: %s,
                 intervener one: %s,
                 intervener two: %s,
                 intervener three: %s,
                 intervener four: %s
                """,
            finremCaseDetails.getId(),
            isApplicantPostalRequired(finremCaseDetails),
            isRespondentPostalRequired(finremCaseDetails),
            isIntervenerOnePostalRequired(finremCaseDetails),
            isIntervenerTwoPostalRequired(finremCaseDetails),
            isIntervenerThreePostalRequired(finremCaseDetails),
            isIntervenerFourPostalRequired(finremCaseDetails)
        );
    }
}
