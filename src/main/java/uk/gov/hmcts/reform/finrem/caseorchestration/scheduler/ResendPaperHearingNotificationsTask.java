package uk.gov.hmcts.reform.finrem.caseorchestration.scheduler;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;
import uk.gov.hmcts.reform.ccd.client.model.CaseDetails;
import uk.gov.hmcts.reform.finrem.caseorchestration.helper.managehearings.HearingCorrespondenceHelper;
import uk.gov.hmcts.reform.finrem.caseorchestration.mapper.FinremCaseDetailsMapper;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.CaseDocument;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.CaseDocumentType;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.CaseType;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.DocumentCollectionItem;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.FinremCaseData;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.FinremCaseDetails;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.managehearings.PartyOnCaseCollectionItem;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.managehearings.hearings.Hearing;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.managehearings.hearings.HearingLike;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.managehearings.hearings.ManageHearingsCollectionItem;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.managehearings.hearings.VacateOrAdjournedHearing;
import uk.gov.hmcts.reform.finrem.caseorchestration.model.ccd.managehearings.hearings.VacatedOrAdjournedHearingsCollectionItem;
import uk.gov.hmcts.reform.finrem.caseorchestration.notifications.notifiers.NotificationParty;
import uk.gov.hmcts.reform.finrem.caseorchestration.notifications.notifiers.SendCorrespondenceEvent;
import uk.gov.hmcts.reform.finrem.caseorchestration.service.CcdService;
import uk.gov.hmcts.reform.finrem.caseorchestration.service.NotificationService;
import uk.gov.hmcts.reform.finrem.caseorchestration.service.SystemUserService;
import uk.gov.hmcts.reform.finrem.caseorchestration.utils.csv.CaseReferenceCsvLoader;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static org.apache.commons.collections4.ListUtils.emptyIfNull;
import static uk.gov.hmcts.reform.finrem.caseorchestration.notifications.notifiers.NotificationParty.getNotificationPartyFromRole;

/**
 * Scheduled task to resend hearing bundle paper correspondence generated by hearing Addition or Vacation.
 * Documents are sent to the applicant / respondent / interveners if they are LiPs.
 * Case references are read from an encrypted file. The file has a header row, and each case reference is on a new line.
 * To enable the task to execute set environment variables:
 * <ul>
 *     <li>CRON_RESEND_PAPER_HEARING_NOTIFICATIONS_ENABLED=true</li>
 *     <li>TASK_NAME=ResendPaperHearingNotificationsTask</li>
 *     <li>CRON_RESEND_PAPER_HEARING_NOTIFICATIONS_CASE_TYPE_ID=Case type for cases in the file</li>
 *     <li>CRON_RESEND_PAPER_HEARING_NOTIFICATIONS_FILENAME=The encrypted case references filename</li>
 *     <li>CRON_CSV_FILE_DECRYPT_KEY=Key to decrypted case references file</li>
 * </ul>
 */
@Component
@Slf4j
public class ResendPaperHearingNotificationsTask extends EncryptedCsvFileProcessingTask {
    private static final String TASK_NAME = "ResendPaperHearingNotificationsTask";
    private static final String SUMMARY = "DFR-4546 - Resend Hearing Notifications for Paper Cases";

    @Value("${cron.resendPaperHearingNotifications.enabled:false}")
    private boolean taskEnabled;
    @Value("${cron.resendPaperHearingNotifications.caseTypeId:FinancialRemedyContested}")
    private String caseTypeId;
    @Value("${cron.resendPaperHearingNotifications.caseListFileName:resendPaperHearingNotifications-encrypted.csv}")
    private String csvFile;
    @Value("${cron.dryRun:false}")
    private boolean dryRun;

    // Service manual hearing notification up until 23:59 2nd March 2026.
    private final LocalDate serviceManualHearingNoticeCutOff = LocalDate.of(2026, 3, 02);
    // Service manual vacate notification up until 23:59 2nd March 2026
    private final LocalDate serviceManualVacatedNoticeCutOff = LocalDate.of(2026, 3, 02);

    private final LocalDate bugIntroductionDate = LocalDate.of(2026, 1, 20);
    private final LocalDate bugFixDate = LocalDate.of(2026, 2, 3);

    private final NotificationService notificationService;
    private final ApplicationEventPublisher applicationEventPublisher;
    private final HearingCorrespondenceHelper hearingCorrespondenceHelper;

    /**
     * Record to hold filtered hearings and vacated hearings.
     *
     * @param hearings        list of active hearings
     * @param vacatedHearings list of vacated or adjourned hearings
     */
    private record HearingsResult(
        List<ManageHearingsCollectionItem> hearings,
        List<VacatedOrAdjournedHearingsCollectionItem> vacatedHearings
    ) {
    }

    public ResendPaperHearingNotificationsTask(CaseReferenceCsvLoader csvLoader, CcdService ccdService,
                                               SystemUserService systemUserService,
                                               FinremCaseDetailsMapper finremCaseDetailsMapper,
                                               NotificationService notificationService,
                                               ApplicationEventPublisher applicationEventPublisher,
                                               HearingCorrespondenceHelper hearingCorrespondenceHelper) {
        super(csvLoader, ccdService, systemUserService, finremCaseDetailsMapper);
        this.notificationService = notificationService;
        this.applicationEventPublisher = applicationEventPublisher;
        this.hearingCorrespondenceHelper = hearingCorrespondenceHelper;
    }

    @Override
    protected boolean isUpdatedRequired(CaseDetails caseDetails) {
        FinremCaseDetails finremCaseDetails = finremCaseDetailsMapper.mapToFinremCaseDetails(caseDetails);

        HearingsResult hearingsResult = getFilteredHearings(finremCaseDetails.getData());

        List<ManageHearingsCollectionItem> hearings = hearingsResult.hearings();
        List<VacatedOrAdjournedHearingsCollectionItem> vacatedHearings = hearingsResult.vacatedHearings();

        // Sanity check notification is after service cutoff time and bug timeframe (for vacated hearings)
        if (hearings.isEmpty() && vacatedHearings.isEmpty()) {
            log.warn("Case ID: {} does not have hearings or vacated hearings within the cut off to post", finremCaseDetails.getId());
            return false;
        }

        // If a LiP has been assigned rep since now and bug introduction, then they will not receive a postal notification.
        return isApplicantPostalRequired(finremCaseDetails)
            || isRespondentPostalRequired(finremCaseDetails)
            || isIntervenerOnePostalRequired(finremCaseDetails)
            || isIntervenerTwoPostalRequired(finremCaseDetails)
            || isIntervenerThreePostalRequired(finremCaseDetails)
            || isIntervenerFourPostalRequired(finremCaseDetails);
    }

    @Override
    protected void executeTask(FinremCaseDetails finremCaseDetails) {
        FinremCaseData caseData = finremCaseDetails.getData();

        String systemUserToken = getSystemUserToken();

        HearingsResult hearingsResult = getFilteredHearings(caseData);

        List<ManageHearingsCollectionItem> hearings = hearingsResult.hearings();
        List<VacatedOrAdjournedHearingsCollectionItem> vacatedHearings = hearingsResult.vacatedHearings();

        logInfoOrTrace("Case ID: {} resending correspondence for {} active hearings and {} vacated hearings",
            finremCaseDetails.getId(), hearings.size(), vacatedHearings.size());

        hearings.forEach(hearing -> processHearingPaperNotification(finremCaseDetails, hearing, systemUserToken));
        vacatedHearings.forEach(vacatedHearing -> processVacatedHearingPaperNotification(finremCaseDetails, vacatedHearing, systemUserToken));
    }

    @Override
    protected String getCaseListFileName() {
        return csvFile;
    }

    @Override
    protected String getTaskName() {
        return TASK_NAME;
    }

    @Override
    protected boolean isTaskEnabled() {
        return taskEnabled;
    }

    @Override
    protected CaseType getCaseType() {
        return CaseType.forValue(caseTypeId);
    }

    @Override
    protected String getSummary() {
        return SUMMARY;
    }

    @Override
    protected String getDescription(FinremCaseDetails finremCaseDetails) {
        return "Resending hearing correspondence for case";
    }

    private boolean isApplicantPostalRequired(FinremCaseDetails caseDetails) {
        return !notificationService.isApplicantSolicitorDigitalAndEmailPopulated(caseDetails);
    }

    private boolean isRespondentPostalRequired(FinremCaseDetails caseDetails) {
        return !notificationService.isRespondentSolicitorDigitalAndEmailPopulated(caseDetails);
    }

    private boolean isIntervenerOnePostalRequired(FinremCaseDetails caseDetails) {
        return !notificationService.isIntervenerSolicitorDigitalAndEmailPopulated(caseDetails.getData().getIntervenerOne(), caseDetails);
    }

    private boolean isIntervenerTwoPostalRequired(FinremCaseDetails caseDetails) {
        return !notificationService.isIntervenerSolicitorDigitalAndEmailPopulated(caseDetails.getData().getIntervenerTwo(), caseDetails);
    }

    private boolean isIntervenerThreePostalRequired(FinremCaseDetails caseDetails) {
        return !notificationService.isIntervenerSolicitorDigitalAndEmailPopulated(caseDetails.getData().getIntervenerThree(), caseDetails);
    }

    private boolean isIntervenerFourPostalRequired(FinremCaseDetails caseDetails) {
        return !notificationService.isIntervenerSolicitorDigitalAndEmailPopulated(caseDetails.getData().getIntervenerFour(), caseDetails);
    }

    private void processHearingPaperNotification(FinremCaseDetails caseDetails, ManageHearingsCollectionItem hearingItem, String authToken) {

        Hearing hearing = hearingItem.getValue();
        List<NotificationParty> partiesToPost = getPostalParties(hearing, caseDetails);

        List<CaseDocument> hearingDocumentsToPost =
            new ArrayList<>(caseDetails.getData().getManageHearingsWrapper().getAssociatedHearingDocuments(hearingItem.getId()));

        // Core hearing documents should always be there
        if (hearingDocumentsToPost.isEmpty()) {
            log.error("Case ID: {} with hearing date {}, for parties: {} contained no hearing documents.",
                caseDetails.getId(), hearing.getHearingDate(), partiesToPost);
            return;
        }

        // Mini form A not always required
        hearingCorrespondenceHelper.getMiniFormAIfRequired(caseDetails.getData(), hearing)
            .ifPresent(hearingDocumentsToPost::add);

        // Additional documents are optional.
        hearingDocumentsToPost.addAll(
            hearing.getAdditionalHearingDocs() == null
                ? List.of()
                : hearing.getAdditionalHearingDocs().stream()
                .map(DocumentCollectionItem::getValue)
                .toList()
        );

        logInfoOrTrace("Case ID: {} Sending active hearing correspondence with hearing date {}, for parties: {}",
            caseDetails.getId(), hearing.getHearingDate(), partiesToPost);

        if (!dryRun) {
            applicationEventPublisher.publishEvent(SendCorrespondenceEvent.builder()
                .notificationParties(partiesToPost)
                .emailNotificationRequest(null)
                .emailTemplate(null)
                .documentsToPost(hearingDocumentsToPost)
                .caseDetails(caseDetails)
                .authToken(authToken)
                .build());
        }
    }

    private void processVacatedHearingPaperNotification(FinremCaseDetails caseDetails,
                                                        VacatedOrAdjournedHearingsCollectionItem vacatedHearingItem,
                                                        String authToken) {
        VacateOrAdjournedHearing vacateHearing = vacatedHearingItem.getValue();

        List<NotificationParty> partiesToPost = getPostalParties(vacateHearing, caseDetails);
        CaseDocument vacateNotice = hearingCorrespondenceHelper.getCaseDocumentByTypeAndHearingUuid(
            CaseDocumentType.VACATE_HEARING_NOTICE, caseDetails.getData().getManageHearingsWrapper(), vacatedHearingItem.getId());

        logInfoOrTrace(
            "Case ID: {} Sending vacated hearing correspondence with Vacated date: {} and hearing date: {}, for parties: {}",
            caseDetails.getId(), vacateHearing.getVacatedOrAdjournedDate(), vacateHearing.getHearingDate(), partiesToPost)
        ;

        if (!dryRun) {
            applicationEventPublisher.publishEvent(SendCorrespondenceEvent.builder()
                .notificationParties(partiesToPost)
                .documentsToPost(List.of(vacateNotice))
                .caseDetails(caseDetails)
                .authToken(authToken)
                .build());
        }
    }

    /**
     * Returns filtered hearings and vacated hearings based on cut-off and bug period.
     * Candidate cases have been identified, and these form the CSV.
     * The bug was fixed 3rd Feb at 11:38.  But this filter, by date, doesn't retrieve those vacated cases.
     * Vacate hearing notices sent before that time are being resent using a manual process.  See DFR-4546.
     * Generally,
     *
     * @param caseData the case data
     * @return a record containing filtered hearings and vacated hearings
     */
    private HearingsResult getFilteredHearings(FinremCaseData caseData) {
        List<ManageHearingsCollectionItem> hearings =
            Optional.ofNullable(caseData.getManageHearingsWrapper().getHearings())
                .orElse(List.of()).stream()
                .filter(hearingItem -> hearingItem.getValue().getHearingDate().isAfter(serviceManualHearingNoticeCutOff))
                .toList();

        List<VacatedOrAdjournedHearingsCollectionItem> vacatedHearings =
            emptyIfNull(caseData.getManageHearingsWrapper().getVacatedOrAdjournedHearings())
                .stream()
                .filter(hearingItem -> hearingItem.getValue().getHearingDate().isAfter(serviceManualVacatedNoticeCutOff))
                .filter(hearingItem ->
                    !hearingItem.getValue().getVacatedOrAdjournedDate().isBefore(bugIntroductionDate) // on or after introduction
                        && !hearingItem.getValue().getVacatedOrAdjournedDate().isAfter(bugFixDate) // on or before fix date
                )
                .toList();

        return new HearingsResult(hearings, vacatedHearings);
    }

    /**
     * Determines if the given party requires postal notification.
     */
    private List<NotificationParty> getPostalParties(HearingLike hearing, FinremCaseDetails caseDetails) {

        List<PartyOnCaseCollectionItem> partiesOnHearing = hearing.getPartiesOnCase();

        return partiesOnHearing.stream()
            .map(partyOnCase -> getNotificationPartyFromRole(partyOnCase.getValue().getRole())).filter(Objects::nonNull)
            .filter(notificationParty -> isPostalRequired(notificationParty, caseDetails))
            .toList();
    }

    private boolean isPostalRequired(NotificationParty party, FinremCaseDetails caseDetails) {
        return switch (party) {
            case APPLICANT -> isApplicantPostalRequired(caseDetails);
            case RESPONDENT -> isRespondentPostalRequired(caseDetails);
            case INTERVENER_ONE -> isIntervenerOnePostalRequired(caseDetails);
            case INTERVENER_TWO -> isIntervenerTwoPostalRequired(caseDetails);
            case INTERVENER_THREE -> isIntervenerThreePostalRequired(caseDetails);
            case INTERVENER_FOUR -> isIntervenerFourPostalRequired(caseDetails);
            default -> false;
        };
    }

    private void logInfoOrTrace(String message, Object... args) {
        if (dryRun) {
            log.trace("[DRY RUN] " + message, args);
        } else {
            log.info(message, args);
        }
    }
}
